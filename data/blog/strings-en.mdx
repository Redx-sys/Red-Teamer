---
title: 'Strings'
date: '2024-07-08'
lastmod: '2023-08-05'
tags: ['english', 'labs', 'mobile', 'android', 'mobilehackinglabs', 'frida', 'fridump']
draft: false
summary: 'In this lab, we are provided with an Android application, and the objective is to find a flag in the format MHL{...}. To achieve this, we will need to reverse engineer the APK, identify the exported activity, find a way to invoke this activity, and use Frida to scan the memory for the flag.'
images: ['/static/images/strings/strings.png']
---

## Introduction

![logo strings](/static/images/strings/strings.png)

"Strings" is a lab available at [MobileHackingLab](https://www.mobilehackinglab.com/link/gnVA9O). In this lab, we are provided with an Android application, and the goal is to find a flag. The format of the flag should be `MHL{...}`. To achieve this, we will need to reverse engineer the APK, identify the exported activity, find a way to invoke the activity, and use Frida to scan the memory in search of the flag.

To accomplish all of this, we'll need a solid understanding of Android applications, reverse engineering on Android apps, and how to use [Frida](https://frida.re/). If you don't yet have this knowledge, don't worry; we'll acquire it as we go through this post and get hands-on.

<TOCInline toc={props.toc} exclude="Introduction" />

### 1. Extract and Decompile the APK

In this lab, we are granted access to an Android device through [Corellium](https://www.corellium.com/solutions/mobile-app-pentesting). Since access is limited, I download the APK to use it on my own emulator.
![Image 1](/static/images/strings/1.png)

We access the provided device and list all installed application packages using `pm list packages`. This list includes both user and system applications. Each application on Android is identified by a unique package name typically following the format **com.companyname.appname**. We are specifically looking for one that contains **_mobilehacking_**, using `grep` to find it.

```shell:ListPackages
pm list packages | grep mobilehacking
```

To obtain the complete path where the APK file is stored, I use `pm path com.mobilehackinglab.challenge`.

```shell:FullPath
pm path com.mobilehackinglab.challenge
```

![Image 2](/static/images/strings/2.png)
![Image 3](/static/images/strings/3.png)

With the path known, I proceed to download the application using `adb pull PATH_TO_APK`. This command transfers the APK file from the Android device to my local computer.

![Image 4](/static/images/strings/4.png)

Next, I decompile the APK into a directory and file structure using [APKTool](https://apktool.org/docs/the-basics/intro), which breaks down the file into its original readable components.

```shell:Decompile
apktool d APP.APK
```

![Image 6](/static/images/strings/6.png)

## 2. Code Review
### 2.1 AndroidManifest
Let's start with AndroidManifest.xml.
![Image 5](/static/images/strings/5.png)

During the code review, we observe:
1. The `com.mobilehacking.challenge.Activity2` activity has the attribute `android:exported="true"`. This indicates that the activity is accessible from outside the application, meaning any app can access and launch it by its exact class name.
2. Within it, we find an `<intent-filter>`, specifying which intents can handle this activity.

Now, what is an Intent? And an Intent-filter?

According to the Android documentation, an Intent ["is basically a passive data structure holding an abstract description of an action to be performed"](https://developer.android.com/reference/android/content/Intent) and also ["is a messaging object you can use to request an action from another app component"](https://developer.android.com/guide/components/intents-filters#Receiving).

A **Intent** is like a request or a message that one application sends to ask another app to perform a specific action. Think of it like a letter an app sends to another app, telling it to do something specific, such as opening a web page, displaying a photo, playing a video, or any other task.

Key features of an intent:
1. **action**: What the application wants to do, such as opening a web page or sending a text message.
2. **data**: Additional details that may accompany the action, such as the web address to open or the photo to display.
3. **category**: Additional tags that can help the application better understand the type of task to perform.

Imagine you're on your Android device and you click on a link to a web page within an app. That app creates an **intent** with the action **VIEW** and the data of the link you clicked. It then sends this **intent** to a web browser. The browser, upon receiving it, understands that it should open that web page because the **intent** has the action **VIEW** and the data with the URL you want to visit.

And **intent-filters** specify what type of **intents** they accept based on the intent's **action**, **data**, and **category**.

```xml:AndroidManifest
<activity android:exported="true" android:name="com.mobilehackinglab.challenge.Activity2">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data android:host="labs" android:scheme="mhl" />
    </intent-filter>
</activity>
```

Let's break down the code:

```xml
<action android:name="android.intent.action.VIEW"/>
```
- `<action>`: Defines the action that the intent can perform. Here, **android.intent.action.VIEW** indicates that the activity can handle intents whose action is to view or display something. It is commonly used to open URLs, view images, open files, etc.
- `android:name`: This is the name of the specific action that the intent-filter is configured to handle.

```xml
<category android:name="android.intent.category.DEFAULT"/>
```
Specifies that this activity can handle the default intent of its type (VIEW in this case).
- `<category>`: Defines the category that the intent belongs to. **android.intent.category.DEFAULT** indicates that this activity is the default action handler for this type of intent if another activity is not explicitly specified.
- `android:name`: This is the name of the specific category that the intent-filter is configured to handle.

```xml
<category android:name="android.intent.category.BROWSABLE"/>
```
- `<category>`: Another category that the intent can have. **android.intent.category.BROWSABLE** indicates that the activity can be launched directly from a web browser as a result of clicking on a link.
- `android:name`: This is the name of the specific category that the intent-filter is configured to handle.

```xml
<data android:host="labs" android:scheme="mhl"/>
```

- `<data>`: Defines the data that the intent can handle. In this case:
  - `android:scheme="mhl"`: Specifies the scheme or protocol of the data. The scheme `mhl` indicates that the intent can handle URIs that start with `mhl://`.
  - `android:host="labs"`: Specifies the host or server to which the intent is directed within the context of the specified scheme. In this case, the host is `labs`.

Now that we have clarified what happens in the code, in short, we need to find a way to access `Activity2` since it has the attribute `android:exported="true"`, thus posing a potential security issue of [Improper Export of Android Application Components](https://cwe.mitre.org/data/definitions/926.html), making it accessible from outside the app itself.

### 2.2 Activity2

Now that we know which activity we can access, let's read its code to understand it.

![Activity2 Code](/static/images/strings/7.png)

```java:Activity2
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_2);
    SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
    String u_1 = sharedPreferences.getString("UUU0133", null);
    boolean isActionView = Intrinsics.areEqual(getIntent().getAction(), "android.intent.action.VIEW");
    boolean isU1Matching = Intrinsics.areEqual(u_1, cd());
    if (isActionView && isU1Matching) {
        Uri uri = getIntent().getData();
        if (uri != null && Intrinsics.areEqual(uri.getScheme(), "mhl") && Intrinsics.areEqual(uri.getHost(), "labs")) {
            String base64Value = uri.getLastPathSegment();
            byte[] decodedValue = Base64.decode(base64Value, 0);
            if (decodedValue != null) {
                String ds = new String(decodedValue, Charsets.UTF_8);
                byte[] bytes = "your_secret_key_1234567890123456".getBytes(Charsets.UTF_8);
                Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
                String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
                if (str.equals(ds)) {
                    System.loadLibrary("flag");
                    String s = getflag();
                    Toast.makeText(getApplicationContext(), s, 1).show();
                    return;
                } else {
                    finishAffinity();
                    finish();
                    System.exit(0);
                    return;
                }
            }
            finishAffinity();
            finish();
            System.exit(0);
            return;
        }
        finishAffinity();
        finish();
        System.exit(0);
        return;
    }
    finishAffinity();
    finish();
    System.exit(0);
}
```

Let's break it down.

```java
...
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_2);
    SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
    String u_1 = sharedPreferences.getString("UUU0133", null);
    boolean isActionView = Intrinsics.areEqual(getIntent().getAction(), "android.intent.action.VIEW");
    boolean isU1Matching = Intrinsics.areEqual(u_1, cd());
...
```

```java
public void onCreate(Bundle savedInstanceState)
```  
When an activity is called or started for the first time, the onCreate(Bundle saveInstanceState) method is responsible for creating the activity.

```java
super.onCreate(savedInstanceState);
```
This calls the superclass onCreate method. This class performs configurations for the activity, such as initializing the user interface and managing the lifecycle.

```java
setContentView(R.layout.activity_2);
```
Sets the layout of an activity on the device screen. `setContentView` takes as argument a reference to a layout resource, in this case `R.layout`. If we navigate through the folder structure generated after decompiling the apk, we understand this structure better.

![APK Folder Structure](/static/images/strings/8.png)

```java
SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
```
Gets an instance of the `SharedPreferences` object associated with the name "DAD4". SharedPreferences are a key-value data store that persists throughout the lifetime of the application. The `0` indicates the access mode, in this case MODE_PRIVATE, meaning that only the app itself has access to these `sharedPreferences`.

```java
String u_1 = sharedPreferences.getString("UUU0133", null);
```
This method retrieves the value associated with the key "UUU0133" from SharedPreferences. If there is no value associated with that key, it returns null.

```java
boolean isActionView = Intrinsics.areEqual(getIntent().getAction(), "android.intent.action.VIEW");
```
**getIntent().getAction()** gets the action associated with the intent that started the activity.
**Intrinsics.areEqual** is a function that compares two values and determines if they are equal.
So, **isActionView** will be True if the action of the intent is "android.intent.action.VIEW", which represents the action of viewing, indicating that the activity is displaying something to the user.

```java
boolean isU1Matching = Intrinsics.areEqual(u_1, cd());
```

`u_1` is a string obtained earlier from SharedPreferences using the key `UUU0133`.
**cd()** is a function, which in this case, its return value is compared with `u_1`, and if they are equal,
`isU1Matching` will be True.

Second part

```java
if (isActionView && isU1Matching) {
            Uri uri = getIntent().getData();
            if (uri != null && Intrinsics.areEqual(uri.getScheme(), "mhl") && Intrinsics.areEqual(uri.getHost(), "labs")) {
                String base64Value = uri.getLastPathSegment();
                byte[] decodedValue = Base64.decode(base64Value, 0);
```

```java
if (isActionView && isU1Matching) {
            Uri uri = getIntent().getData();
```

If `isActionView` and `isU1Matching` are True, it retrieves the `uri` associated with that intent, allowing access to more information.

```java
if (uri != null && Intrinsics.areEqual(uri.getScheme(), "mhl") && Intrinsics.areEqual(uri.getHost(), "labs")) {
            String base64Value = uri.getLastPathSegment();
            byte[] decodedValue = Base64.decode(base64Value, 0);
```

Checks that `uri` is not empty, that the `scheme` is equal to "mhl", and that the `host` is equal to "labs".
`uri.getLastPathSegment()` gets the last segment of the URI path. It assumes this segment contains a Base64-encoded value and decodes the Base64 value stored in `base64Value`.

```java
if (decodedValue != null) {
                    String ds = new String(decodedValue, Charsets.UTF_8);
                    byte[] bytes = "your_secret_key_1234567890123456".getBytes(Charsets.UTF_8);
                    Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
                    String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
```

If `decodedValue` is not empty, it proceeds with the code block. **String ds = new String(decodedValue, Charsets.UTF_8)** converts the byte array to a string. This decodes the Base64-decoded data to its text representation.
Then it creates a byte array from the string "your_secret_key_1234567890123456", using UTF-8 encoding. This byte array serves as the secret key for the AES decryption process.
This line seems to be an internal validation or a null-check for the byte array.

```java
String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
```

Invokes a decrypt function to decrypt an encrypted text using the AES algorithm in CBC (Cipher Block Chaining) mode with PKCS5Padding padding. A secret key ("your_secret_key_1234567890123456") derived from the byte array created earlier is used.

In summary: once it verifies that `decodedValue` is not `null`, it converts it to a string (`ds`) and prepares a secret key (`bytes`) for the AES decryption process.

```java
if (str.equals(ds)) {
    System.loadLibrary("flag");
    String s = getflag();
    Toast.makeText(getApplicationContext(), s, 1).show();
    return;
```
Compares `str` with `ds`. Then it loads a native library named "flag".

>Native libraries are compiled files that contain functions implemented in languages like C or C++, and they are used when specific performance or functionality is needed that Java runtime does not provide directly.

It calls **getflag()** to retrieve the flag.
**Toast.makeText(getApplicationContext(), s, 1).show()** displays a short-lived visual message (toast) in the application with the content of string `s`.
Toast messages are brief visual notifications that appear temporarily on the screen.

Alright, so far so good, we just need to read two more methods that we already mentioned earlier, `decrypt` and `cd`.

![Method: decrypt and cd](/static/images/strings/9.png)

```java:Decrypt
String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
....
<SNIP>
....
  public final String decrypt(String algorithm, String cipherText, SecretKeySpec key) {
        Intrinsics.checkNotNullParameter(algorithm, "algorithm");
        Intrinsics.checkNotNullParameter(cipherText, "cipherText");
        Intrinsics.checkNotNullParameter(key, "key");
        Cipher cipher = Cipher.getInstance(algorithm);
        try {
            byte[] bytes = Activity2Kt.fixedIV.getBytes(Charsets.UTF_8);
            Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
            IvParameterSpec ivSpec = new IvParameterSpec(bytes);
            cipher.init(2, key, ivSpec);
            byte[] decodedCipherText = Base64.decode(cipherText, 0);
            byte[] decrypted = cipher.doFinal(decodedCipherText);
            Intrinsics.checkNotNull(decrypted);
            return new String(decrypted, Charsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Decryption failed", e);
        }
    }
...
```

```java
decrypt(String algorithm, String cipherText, SecretKeySpec key)
```

- `algorithm`: It is the encryption algorithm that will be used.
- `cipherText`: The encrypted text to be decrypted.
- `key`: The secret key used for encryption and decryption.

`Intrinsics.checkNotNullParameter` ensures that none of the parameters passed to it are null. This validation is crucial for preventing [NullPointerExceptions](https://rollbar.com/blog/how-to-catch-and-fix-nullpointerexception-in-java/#:~:text=NullPointerException%20is%20a%20runtime%20exception,refers%20to%20nothing%20or%20null%20objects.).

```java
Cipher cipher = Cipher.getInstance(algorithm);
```
Creates an instance of the `Cipher` class using the specified encryption `algorithm`. `Cipher` is the central class in Java for performing encryption and decryption operations.

```java
byte[] bytes = Activity2Kt.fixedIV.getBytes(Charsets.UTF_8);
```
Obtains a fixed initialization vector (IV) as a byte array in UTF-8 encoding. The IV is used along with the key to initialize the `Cipher` object in certain encryption modes like CBC (Cipher Block Chaining).

![Fixed IV](/static/images/strings/10.png)

```java
IvParameterSpec ivSpec = new IvParameterSpec(bytes);
```
Creates an object that encapsulates the IV (`ivSpec`).

```java
cipher.init(2, key, ivSpec);
```
Initializes the `Cipher` object in decryption mode (`Cipher.DECRYPT_MODE`) with the secret `key` and the `ivSpec` provided.

```java
byte[] decodedCipherText = Base64.decode(cipherText, 0);
byte[] decrypted = cipher.doFinal(decodedCipherText);
Intrinsics.checkNotNull(decrypted);
return new String(decrypted, Charsets.UTF_8);
```
Decode the encrypted text (`cipherText`) from Base64 into a byte array (`decodedCipherText`). 
Perform the final decryption operation on the decoded data, producing the decrypted result in the byte array `decrypted`. Finally, return it.

```java:cd
private final String cd() {
    String str;
    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
    String format = sdf.format(new Date());
    Intrinsics.checkNotNullExpressionValue(format, "format(...)");
    Activity2Kt.cu_d = format;
    str = Activity2Kt.cu_d;
    if (str != null) {
        return str;
    }
    Intrinsics.throwUninitializedPropertyAccessException("cu_d");
    return null;
}
```

Returns a string formatted with the current date in the "dd/MM/yyyy" format. `Activity2Kt.cu_d = format` assigns the value of `format` to the static variable `cu_d` in the `Activity2Kt` class. Finally, the value of `cu_d` is assigned to the variable `str`, and if it is not null, it is returned.

![](/static/images/strings/11.png)

### 2.3.MainActivity

The last block of code that we are interested in is found in MainActivity.

![](/static/images/strings/12.png)

```java
public final void KLOW() {
    SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
    SharedPreferences.Editor editor = sharedPreferences.edit();
    Intrinsics.checkNotNullExpressionValue(editor, "edit(...)");
    SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
    String cu_d = sdf.format(new Date());
    editor.putString("UUU0133", cu_d);
    editor.apply();
}
```

```java
SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
SharedPreferences.Editor editor = sharedPreferences.edit();
```
Obtains an instance of SharedPreferences with the name "DAD4" and then
a SharedPreferences editor to modify preferences.

```java
SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy", Locale.getDefault());
String cu_d = sdf.format(new Date());
```

Creates an instance of SimpleDateFormat to format the current date as "dd/MM/yyyy" and
saves the formatted current date as "dd/MM/yyyy" into `cu_d`.

```java
editor.putString("UUU0133", cu_d);
editor.apply();
```

Finally, saves the formatted date into SharedPreferences with the key "UUU0133"
and applies the changes to the editor.

## 3. Resolution

#### 3.1. From Back to Front

```
if (str.equals(ds)) {
    System.loadLibrary("flag");
    String s = getflag();
    Toast.makeText(getApplicationContext(), s, 1).show();
    return;
```

In this `if` statement, if the value of `str` is equal to `ds`, the `getFlag` function is called.
The value of `ds` comes through an intent with the scheme "mhl" and host "labs", it's the last segment of the URI path,
and we assume it is in base64 format (from the code review) and converted to a string.
So, we would have something like this:

```code
mhl://labs/[ds]
```

We don't know the value of `ds`, but we can obtain the value of `str`, which is passed to the `decrypt` function. We have the following details:

- key = your_secret_key_1234567890123456
- IV = 1234567890123456
- Mode = CBC
- Base64 Value = bqGrDKdQ8zo26HflRsGvVA==

Using CyberChef, we can decrypt this value.
![](/static/images/strings/13.png)

The value of `ds` in plain text is `mhl_secret_1337`, and if encoded in base64 it becomes `bWhsX3NlY3JldF8xMzM3`.
![](/static/images/strings/14.png)

```java
mhl://labs/bWhsX3NlY3JldF8xMzM3
```

#### 3.2 KLOW()

This method is not called anywhere in the code, hence, the object associated with the name `DAD4` is not being generated when the activity is called, which is what is expected to happen when the other methods and if statements are complied with until getFlag().

For this occasion and to obtain the flag, we are going to invoke the method `KLOW()` using Frida through a script and accessing Activity2 with the URI and adb to finally dump the memory and search for the flag.

```javascript:Invoke.js
Java.perform(function(){
    setTimeout(function(){
        Java.choose("com.mobilehackinglab.challenge.MainActivity", {
            onMatch: function(instance){
                instance.KLOW.implementation = function() {
                    console.log("Llamada interceptada a KLOW()");
                    this.KLOW();
                };
                instance.KLOW();
                console.log("Invocado el método KLOW");
            },
            onComplete: function() {
                console.log("Búsqueda completada");
            }
        });
    }, 8000);
});
```

This JavaScript code uses the Frida library for dynamic instrumentation of the Strings application. It waits for 8 seconds after launching the application, searches for instances of the MainActivity class, intercepts and redefines the KLOW() function in each found instance, prints messages indicating when KLOW() is intercepted and called, and finally prints a message when the instance search is completed.

This is the complete process that we executed:
![](/static/images/strings/flag.png)

1. We start the Frida server from our host. (Previously, I placed `frida-server` inside the emulator with `adb push frida-server /data/local/tmp/`.)
![](/static/images/strings/16.png)

2. Inside the application's shared_prefs, I see that I still do not have any generated file.
![](/static/images/strings/17.png)

3. With Frida, I launch the app and inject and execute the script that will invoke KLOW().
```js
frida -U -f com.mobilehackinglab.challenge -l invoque.js
```
![](/static/images/strings/18.png)

4. After invoking the KLOW() method, we see a file generated in shared_prefs.
![](/static/images/strings/19.png)

5. I see that the `DAD4.xml` file was generated.

6. Inside it, it contains the name `UUU0133`.

7. With the file generated, I call Activity2 so that all the remaining code block executes.
```js 
adb shell am start -W -a android.intent.action.VIEW -d "mhl://labs/bWhsX3NlY3JldF8xMzM3" -n com.mobilehackinglab.challenge/.Activity2
```
![](/static/images/strings/20.png)
Lastly, I use [Fridump](https://github.com/Nightbringer21/fridump) to dump the memory and find the flag.

![](/static/images/strings/15.png)

-----

## References

1. https://developer.android.com/reference/android/content/Intent
2. https://developer.android.com/privacy-and-security/risks/android-exported
3. https://codeql.github.com/codeql-query-help/java/java-android-implicitly-exported-component/
4. https://developer.android.com/guide/components/intents-filters
5. https://abhiandroid.com/programming/oncreate-activity-android.html#gsc.tab=0
6. https://stackoverflow.com/questions/48122980/what-does-0-mean-in-getsharedpreferences
7. https://stackoverflow.com/questions/39897378/what-does-the-number-mean-in-base64-encodetostringdata-number
8. https://stackoverflow.com/questions/44782228/adb-launching-view-intent-from-adb-with-multiple-parameters-in-uri
9. https://medium.com/@prnz_offl/dumping-android-application-memory-with-fridump-7adf2ca48fa3
10. https://securitygrind.com/dumping-android-application-memory-with-fridump/
11. https://labs.cognisys.group/posts/Writing-your-first-Frida-script-for-Android/
12. https://frida.re/docs/javascript-api/#frida