---
title: 'Strings'
date: '2024-07-07'
lastmod: '2023-08-05'
tags: ['labs', 'mobile', 'android', 'mobilehackinglabs']
draft: false
summary: 'En este laboratorio se nos proporciona una aplicacion de Android y el objetivo es encontrar una bandera. El formato tiene que ser `MHL{...}`. Para esto vamos a tener que realizar ingenieria inversa a la apk, identificar la actividad exportada, encontrar una manera de invocar la actividad y utlizar frida para escanear la memoria en busca de la bandera.'
images: ['/static/images/strings/strings.png']
---

## Introduccion

![logo strings](/static/images/strings/strings.png)

Strings es un laboratorio que se encuentra disponible en [MobileHackingLab](https://www.mobilehackinglab.com/link/gnVA9O).
En este laboratorio se nos proporciona una aplicacion de Android y el objetivo es encontrar una bandera. 
El formato tiene que ser `MHL{...}`. Para esto vamos a tener que realizar ingenieria inversa a la apk, identificar 
la actividad exportada, encontrar una manera de invocar la actividad y utlizar frida para escanear la memoria en busca de la flag. 

Para todo esto vamos a tener que tener una comprension de las aplicaciones Android, 
de ingenieria inversa en aplicaciones Android y saber como usar [Frida](https://frida.re/).
Si aun no tenemos ese conocimiento, relax, lo vamos a ir obteniendo sobre la marcha a medida que avancemos en este post y metamos manos.


<TOCInline toc={props.toc} exclude="Introduction" />

## 1.Extraer y decompilar la APK

En este laboratorio se nos da acceso a un dispositivo Android por medio de [Corellium](https://www.corellium.com/solutions/mobile-app-pentesting), como el acceso es limitado,me descargo la apk para hacerlo en mi propio emulador. 
![Image 1](/static/images/strings/1.png)


Ingresamos al dispositivo que se nos proporciona y para listar todos los paquetes de aplicaciones instaladas en 
el dispositivo usamos `pm list packages`. Esta lista incluye tanto las aplicaciones del usuario como las del dispositivo. 
Cada aplicacion en Android se identifica mediante un nombre de paquete unico que generalmente sigue el formato 
**com.nombredeempresa.nombredeaplicacion**. Y como estamos buscando uno en particular. utilizamos grep para encontrar uno que diga 
**_mobilehacking_**.

```shell:ListarPaquetes
pm list packages | grep mobilehacking
```

Para obtener la ruta completa donde se encuentra almacenado el archivo apk de la aplicacion utilizo `pm path com.mobilehacking.challenge`.

```shell:RutaCompleta
pm path com.mobilehackinglab.challenge
```
![](/static/images/strings/2.png)

![](/static/images/strings/3.png)

Sabiendo la ruta donde se encuentra la aplicacion,procedemos a descargarla con `adb pull PATH_TO_APK`.
Con este comando lo que hacemos es transferir el archivo apk desde el dispositivo Android a la computadora local.

![](/static/images/strings/4.png)

Ahora descomprimimos el archivo APK en una estructura de directorios y archivos con [APKTool](https://apktool.org/docs/the-basics/intro), que descompila el archivo en sus componentes originales en formato legible. 

```shell:Decompile
apktool d APP.APK
```

![](/static/images/strings/6.png)

## 2.Code Review
### 2.1.AndroidManifest
Comencemos por el AndroidManifest.xml.
![](/static/images/strings/5.png)

Al hacer code review vemos que:
1. La _activty_ `com.mobilehacking.challenge.Activity2` tiene el atributo `android:exported="true"`. Esto indica que la _Activity_ es accesible desde fuera de la aplicacion, osea, cualquier aplicacion puede acceder a ella e iniciarla por su nombre de clase exacto.
2. Dentro de ella encontramos un _Intent-filter_, especificando que _Intents_ pueden manejar esta _activity_.

OK, pero que es un Intent? Y un Intent-filter?

En la documentacion de Android encontramos que un Intent [_“es básicamente una estructura de datos pasiva que contiene una descripción abstracta de una acción a realizar”_](https://developer.android.com/reference/android/content/Intent) y tambien [_“es un objeto de mensajería que puede utilizar para solicitar una acción desde otro componente de la aplicacion“_](https://developer.android.com/guide/components/intents-filters#Receiving). Bajemoslo a tierra.

Un **Intent** es como una peticion o un mensaje que una aplicacion envia para pedir a otra app que haga algo especifico.Puedes pensar en ello como una especie de carta que una app le envia a otra para decirle que haga una **ACCION** determinada, como abrir una pagina web, mostrar una foto, reproducir un video o otra tarea.

Características principales de un intent:
1. **action**: Es lo que la aplicación quiere hacer, como abrir una página web o enviar un mensaje de texto.
2. **data**: Son detalles adicionales que pueden acompañar a la acción, como la dirección web que se desea abrir o la foto que se desea mostrar.
3. **category**: Son etiquetas adicionales que pueden ayudar a la aplicación a entender mejor el tipo de tarea que se quiere realizar.

Imagina que estás en tu Android y haces clic en un enlace a una página web dentro de una aplicación. Esa aplicación crea un **intent** con la acción de **VIEW** y los datos del enlace que clicaste. Luego, le envía este **intent** a un navegador web. El navegador, al recibirlo, entiende que debe abrir esa página web porque el **intent** tiene la acción de **view** y los datos de la URL que quieres visitar.

Y los **intent-filter** especifican el tipo de **intent** que acepta en funcion de la _action_,_data_ y _category_ del intent.

```xml:AndroidManifest
<activity android:exported="true" android:name="com.mobilehackinglab.challenge.Activity2">
    <intent-filter>
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data android:host="labs" android:scheme="mhl" />
    </intent-filter>
</activity>
```

Desglozemos el codigo:

```xml
<action android:name="android.intent.action.VIEW"/>
```
- `<action>`: Define la acción que el intent puede realizar. En este caso, **android.intent.action.VIEW** indica que la actividad puede manejar intents cuya acción sea ver o mostrar algo. Es comúnmente utilizado para abrir URLs, ver imágenes, abrir archivos, etc.
- `android:name`: Es el nombre de la acción específica que el intent-filter está configurado para manejar.

```xml
<category android:name="android.intent.category.DEFAULT"/>
```
Especifica que esta actividad puede manejar el intent por defecto de su tipo (VIEW en este caso).
- `<category>`: Define la categoría a la que pertenece el intent. **android.intent.category.DEFAULT** indica que esta actividad es la acción predeterminada para manejar este tipo de intent si no se especifica otra actividad explícitamente.
- `android:name`: Es el nombre de la categoría específica que el intent-filter está configurado para manejar.

```xml
<category android:name="android.intent.category.BROWSABLE"/>
```
- `<category>`: Otra categoría que puede tener el intent. **android.intent.category.BROWSABLE** indica que la actividad puede ser lanzada directamente desde un navegador web como resultado de hacer clic en un enlace.
- `android:name`: Es el nombre de la categoría específica que el intent-filter está configurado para manejar.

```xml
<data android:host="labs" android:scheme="mhl"/>
```

- `<data>:` Define los datos que el intent puede manejar. En este caso:
  - `android:scheme="mhl"`: Especifica el esquema o protocolo de los datos. El esquema `mhl` indica que el intent puede manejar URIs que comiencen con `mhl://`.
  - `android:host="labs"`: Especifica el host o servidor al que se dirige el intent dentro del contexto del esquema especificado. En este caso, el host es `labs`.


Habiendo dejado claro lo que ocurre en el codigo, en pocas palabras, tenemos que encontrar una forma de poder acceder a la Activity2 ya que posee el atributo `android:exported="true"`
teniendo un problema de [Improper Export of Android Application Components](https://cwe.mitre.org/data/definitions/926.html) siendo accesible desde fuera de la app propia.

### 2.2.Activity2

Ahora que sabemos que activity es a la que podemos acceder, leamos su codigo para entender.

![](/static/images/strings/7.png)

```java:Activity2
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_2);
        SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
        String u_1 = sharedPreferences.getString("UUU0133", null);
        boolean isActionView = Intrinsics.areEqual(getIntent().getAction(), "android.intent.action.VIEW");
        boolean isU1Matching = Intrinsics.areEqual(u_1, cd());
        if (isActionView && isU1Matching) {
            Uri uri = getIntent().getData();
            if (uri != null && Intrinsics.areEqual(uri.getScheme(), "mhl") && Intrinsics.areEqual(uri.getHost(), "labs")) {
                String base64Value = uri.getLastPathSegment();
                byte[] decodedValue = Base64.decode(base64Value, 0);
                if (decodedValue != null) {
                    String ds = new String(decodedValue, Charsets.UTF_8);
                    byte[] bytes = "your_secret_key_1234567890123456".getBytes(Charsets.UTF_8);
                    Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
                    String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
                    if (str.equals(ds)) {
                        System.loadLibrary("flag");
                        String s = getflag();
                        Toast.makeText(getApplicationContext(), s, 1).show();
                        return;
                    } else {
                        finishAffinity();
                        finish();
                        System.exit(0);
                        return;
                    }
                }
                finishAffinity();
                finish();
                System.exit(0);
                return;
            }
            finishAffinity();
            finish();
            System.exit(0);
            return;
        }
        finishAffinity();
        finish();
        System.exit(0);
    }
```

Vayamos por partes.

```java
...
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_2);
    SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
    String u_1 = sharedPreferences.getString("UUU0133", null);
    boolean isActionView = Intrinsics.areEqual(getIntent().getAction(), "android.intent.action.VIEW");
    boolean isU1Matching = Intrinsics.areEqual(u_1, cd());
...
```

```java
public void onCreate(Bundle savedInstanceState)
```  
Cuando una actividad se llama o se inicia por primera vez, el método onCreate(Bundle saveInstanceState) es responsable de crear la actividad..

```java
super.onCreate(savedInstanceState);
```
Llama la clase onCreate,esta clase realiza configuraciones para la activity,
como la incializacion de la interfaz de usuario y la gestion del ciclo de vida.

```java
setContentView(R.layout.activity_2);
```
Establece el diseno de una activity en la pantalla del dispositivo. `setContentView` toma como argumento una referencia a un recurso
de diseno,en este caso `R.layout`. Si vamos a la estructura de carpetas generada luego de decompilar la apk entendemos mejor esa estructura.

![](/static/images/strings/8.png)

```java
SharedPreferences sharedPreferences = getSharedPreferences("DAD4", 0);
```
Obtiene una instancia del objeto `SharedPreferences` asociada con el nombre "DAD4". Los SharedPreferences
son un almacen de datos clave-valor que persisten en toda la vida de la aplicacion. El 0, indica el modo de acceso
,en este caso MODE_PRIVATE, que significa que solo la app tiene acceso a estos `sharedPreferences`.

```java
String u_1 = sharedPreferences.getString("UUU0133", null);
```
Este método obtiene el valor asociado con la clave "UUU0133" de los SharedPreferences. 
Si no hay ningún valor asociado con esa clave, devuelve null.

```java
boolean isActionView = Intrinsics.areEqual(getIntent().getAction(), "android.intent.action.VIEW");
```
**getIntent().getAction()** obtiene la action asociada con la intent que inicio la activity.
E **Intrinsics.areEqual** es una funcion que compara dos valores y determina si son iguales.
Entonces, **isActionView** sera True, si la action del intent es "android.intent.action.VIEW",
que representa la accion de visualizar, que indica que la actividad esta mostrando algo al usuario.

```java
boolean isU1Matching = Intrinsics.areEqual(u_1, cd());
```

`u_1` es un string que se obtuvo anteriormente de los **sharedPreferences**, usando la clave `UUU0133`.
**cd()** es una funcion, que en este caso, el valor que devuelve **cd()** se compara con `u_1`, y en caso de que 
sean iguales, `isU1Matching` sera True.

Segunda parte

```java
if (isActionView && isU1Matching) {
            Uri uri = getIntent().getData();
            if (uri != null && Intrinsics.areEqual(uri.getScheme(), "mhl") && Intrinsics.areEqual(uri.getHost(), "labs")) {
                String base64Value = uri.getLastPathSegment();
                byte[] decodedValue = Base64.decode(base64Value, 0);
                if (decodedValue != null) {
                    String ds = new String(decodedValue, Charsets.UTF_8);
                    byte[] bytes = "your_secret_key_1234567890123456".getBytes(Charsets.UTF_8);
                    Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
                    String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
                    if (str.equals(ds)) {
                        System.loadLibrary("flag");
                        String s = getflag();
                        Toast.makeText(getApplicationContext(), s, 1).show();
                        return;
```

```java
if (isActionView && isU1Matching) {
            Uri uri = getIntent().getData();
```

Si `isActionView` y `isU1Matching` son True, obtiene la `uri` asociada a ese intent, permitiendo
acceder a mas informacion.

```java
if (uri != null && Intrinsics.areEqual(uri.getScheme(), "mhl") && Intrinsics.areEqual(uri.getHost(), "labs")) {
            String base64Value = uri.getLastPathSegment();
            byte[] decodedValue = Base64.decode(base64Value, 0);
```

Verifica que `uri` no esta vacia, que el `scheme` sea igual a "mhl" y que el `host` sea igual a "labs".
`uri.getLastPathSegment()` obtiene el último segmento de la ruta de la URI. 
Se asume que este segmento contiene un valor en formato Base64 y decodifica el valor Base64 almacenado en base64Value.

```java
if (decodedValue != null) {
                    String ds = new String(decodedValue, Charsets.UTF_8);
                    byte[] bytes = "your_secret_key_1234567890123456".getBytes(Charsets.UTF_8);
                    Intrinsics.checkNotNullExpressionValue(bytes, "this as java.lang.String).getBytes(charset)");
                    String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
```

Si decodeValue no es vacio, procede con el bloque de codigo. **String ds = new String(decodedValue, Charsets.UTF_8)** convierte el arreglo
a un string. Esto convierte los datos decodificados de Base64 a su representación de texto.
Luego,crea un arreglo de bytes a partir de la cadena "your_secret_key_1234567890123456", utilizando UTF-8 como codificación. 
Este arreglo de bytes se usa como clave secreta para el proceso de descifrado.
Esta línea parece ser una validación interna o un chequeo de no nulidad para el arreglo de bytes. 

```java
String str = decrypt("AES/CBC/PKCS5Padding", "bqGrDKdQ8zo26HflRsGvVA==", new SecretKeySpec(bytes, "AES"));
```
Invoca una funcion decrypt para descifrar un texto cifrado utilizando el algoritmo AES en modo CBC(Cipher Block Chaining) con 
relleno PKCS5Padding. Se utiliza una clave secreta ("your_secret_key_1234567890123456") derivada del arreglo de bytes 
creado anteriormente.

En resumen: una vez que se verifica que `decodeValue` no es `null`, se convierte a un string (`ds`) y se prepara una clave secreta (`bytes`)
para el proceso de descifrado AES.

```java
if (str.equals(ds)) {
    System.loadLibrary("flag");
    String s = getflag();
    Toast.makeText(getApplicationContext(), s, 1).show();
    return;
```
Compara `str` con `ds`. Luego se carga una biblioteca nativa llamada "flag"

>Las bibliotecas nativas son archivos compilados que contienen funciones implementadas en lenguajes como C o C++, y se utilizan cuando se requiere un rendimiento o funcionalidad específica no proporcionada directamente por el entorno de ejecución Java.

Llama a la **getflag()** para obtener la bandera.
**Toast.makeText(getApplicationContext(), s, 1).show()** muestra un mensaje emergente (toast) en la aplicación con el contenido de la cadena s. 
Los mensajes Toast son breves notificaciones visuales que aparecen temporalmente en la pantalla.

-----

## Referencias

1. https://developer.android.com/reference/android/content/Intent
2. https://developer.android.com/privacy-and-security/risks/android-exported
3. https://codeql.github.com/codeql-query-help/java/java-android-implicitly-exported-component/
4. https://developer.android.com/guide/components/intents-filters
5. https://abhiandroid.com/programming/oncreate-activity-android.html#gsc.tab=0
6. https://stackoverflow.com/questions/48122980/what-does-0-mean-in-getsharedpreferences
7. https://stackoverflow.com/questions/39897378/what-does-the-number-mean-in-base64-encodetostringdata-number
